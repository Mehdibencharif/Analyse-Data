import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from io import BytesIO
from datetime import timedelta
import re
import unicodedata

from pandas.api.types import is_numeric_dtype

def coerce_numeric_general(df: pd.DataFrame, threshold: float = 0.6) -> pd.DataFrame:
    """
    Force les colonnes majoritairement num√©riques en float.
    Les placeholders ou textes parasites deviennent NaN.
    """
    for col in df.columns:
        if col.lower() in ("timestamp", "notes"):
            continue
        s = df[col]
        if not is_numeric_dtype(s):
            s2 = s.astype(str).str.replace(",", ".", regex=False).str.strip()
            s2 = s2.replace(list(PLACEHOLDER_NULLS), pd.NA)
            numeric = pd.to_numeric(s2, errors="coerce")
            # si la majorit√© est num√©rique, on conserve
            if numeric.notna().mean() >= threshold:
                df[col] = numeric
    return df
    
# Valeurs consid√©r√©es comme "vides" ou "nulles"
PLACEHOLDER_NULLS = {"", " ", "-", "‚Äî", "‚Äì", "NA", "N/A", "na", "n/a", "null", "None"}

def series_with_true_nans(s: pd.Series) -> pd.Series:
    """Transforme les placeholders en vrais NaN pour bien compter les manquants."""
    if s.dtype == object:
        s = s.astype(str).str.strip()
        s = s.replace(list(PLACEHOLDER_NULLS), pd.NA)
        s = s.replace(r"^\s+$", pd.NA, regex=True)
    return s

# Motif pour reconna√Ætre les colonnes de temp√©rature
TEMP_NAME_RE = re.compile(r"(?i)(temp|temperature|¬∞\s*c|degc|degre|¬∞c|\[¬∞c\])")

def coerce_temperature_columns(df: pd.DataFrame) -> pd.DataFrame:
    """Convertit les colonnes de temp√©rature en float (NaN si non num√©rique)."""
    for col in df.columns:
        if col.lower() in ("timestamp", "notes"):
            continue
        name = str(col)
        if TEMP_NAME_RE.search(name):
            s = df[col]
            if s.dtype == object:
                s = s.astype(str).str.replace(",", ".", regex=False).str.strip()
                s = s.replace(list(PLACEHOLDER_NULLS), pd.NA)
            df[col] = pd.to_numeric(s, errors="coerce")
    return df

# ------------- Configuration de la page Streamlit -------------
st.set_page_config(page_title="Analyse de donn√©es capteurs", layout="wide")
st.title("üìä Analyse de donn√©es ")

# ------------- Param√®tres de fr√©quence d'analyse -------------
st.sidebar.header("Param√®tres d'analyse")
frequence = st.sidebar.selectbox(
    "Choisissez la fr√©quence d'analyse :",
    ["1min", "5min", "10min", "15min", "1H"]
)
rule_map = {
    "1min": "1min",
    "5min": "5min",
    "10min": "10min",
    "15min": "15min",
    "1H": "1H"
}

# ------------- T√©l√©versement des fichiers -------------
st.sidebar.subheader("T√©l√©versement des fichiers")
main_file = st.sidebar.file_uploader(
    "üìÇ Fichier principal (obligatoire)",
    type=[".xlsx", ".xls", ".xlsm"],
    key="main"
)
compare_file = st.sidebar.file_uploader(
    "üìÇ Fichier de comparaison (facultatif)",
    type=[".xlsx", ".xls", ".xlsm"],
    key="compare"
)

# ------------- Fonction de chargement de fichier -------------
def charger_et_resampler(fichier, nom_fichier):
    xls = pd.ExcelFile(fichier)
    feuille = xls.sheet_names[0] if len(xls.sheet_names) == 1 else st.selectbox(
        f"üìÑ Feuille √† utiliser pour {nom_fichier}",
        xls.sheet_names,
        key=nom_fichier
    )
    df = pd.read_excel(xls, sheet_name=feuille)
    df.columns = [str(c).strip() for c in df.columns]
    df = df.rename(columns={df.columns[0]: "timestamp"})
    df["timestamp"] = pd.to_datetime(df["timestamp"], errors="coerce")
    df = df.dropna(subset=["timestamp"]).sort_values("timestamp").reset_index(drop=True)
    return df

# ------------- V√©rification de la pr√©sence du fichier principal -------------
if not main_file:
    st.warning("‚ö†Ô∏è Veuillez t√©l√©verser un fichier principal pour d√©marrer l‚Äôanalyse.")
    st.stop()

# üì• Chargement du fichier principal
df_main = charger_et_resampler(main_file, "Fichier principal")

# üßº Conversion des colonnes de temp√©rature en num√©rique
df_main = coerce_temperature_columns(df_main)
df_main = coerce_numeric_general(df_main)  # üîß force toutes les colonnes majoritairement num√©riques

# -------- Nettoyage des noms de capteurs (pour la comparaison uniquement) --------
def nettoyer_nom_capteur(nom: str) -> str:
    """
    Supprime les unit√©s entre crochets [] ou parenth√®ses () et les espaces inutiles.
    Exemples :
      'Temp-1 [¬∞C]'      -> 'Temp-1'
      'D√©bit (Gpm)'      -> 'D√©bit'
      'Pression [bar] '  -> 'Pression'
    """
    s = str(nom)
    s = re.sub(r"\s*[\[\(].*?[\]\)]", "", s)  # enl√®ve [ ... ] ou ( ... )
    return s.strip()

# üßº Copie "nettoy√©e" des colonnes du fichier principal (SEULEMENT pour la comparaison)
df_main_cleaned = df_main.copy()
df_main_cleaned.columns = [
    "timestamp" if c == "timestamp" else nettoyer_nom_capteur(c)
    for c in df_main_cleaned.columns
]

# üìë Lecture du fichier de comparaison (capteurs attendus) + versions nettoy√©es
df_compare = None
capteurs_reference = None
capteurs_reference_cleaned = None

if compare_file:
    try:
        df_compare = pd.read_excel(compare_file)
        if "Description" not in df_compare.columns:
            st.error("‚ùå Le fichier de comparaison doit contenir une colonne 'Description'.")
            st.stop()

        # Ensemble brut + ensemble nettoy√©
        df_compare["Description"] = df_compare["Description"].astype(str).str.strip()
        capteurs_reference = set(df_compare["Description"])
        capteurs_reference_cleaned = {nettoyer_nom_capteur(c) for c in capteurs_reference}

        st.success("‚úÖ Fichier de comparaison charg√© avec succ√®s.")
    except Exception as e:
        st.error(f"‚ùå Erreur lors de la lecture du fichier de comparaison : {e}")
        st.stop()
else:
    st.info("‚ÑπÔ∏è Aucun fichier de comparaison n'a √©t√© t√©l√©vers√© (facultatif).")

# --- Analyse simple ---
def analyse_simplifiee(df):
    st.subheader("Pr√©sentes vs Manquantes ‚Äì M√©thode simple")
    total = len(df)
    resume = []

    for col in df.columns:
        if col.lower() in ['timestamp', 'notes']:
            continue

        presente = df[col].notna().sum()
        manquantes = total - presente
        pct_presente = 100 * presente / total if total > 0 else 0
        pct_manquantes = 100 - pct_presente
        statut = "üü¢" if pct_presente >= 80 else ("üü†" if pct_presente > 0 else "üî¥")

        resume.append({
            "Capteur": str(col).strip(),
            "Pr√©sentes": int(presente),
            "% Pr√©sentes": round(pct_presente, 2),
            "Manquantes": int(manquantes),
            "% Manquantes": round(pct_manquantes, 2),
            "Statut": statut
        })

    df_resume = pd.DataFrame(resume)

    # Ajout d'une colonne nettoy√©e pour les comparaisons (sans affecter les noms affich√©s)
    df_resume["Nom_nettoye"] = df_resume["Capteur"].astype(str).apply(nettoyer_nom_capteur)

    # Affichage tableau
    st.dataframe(df_resume, use_container_width=True)
    return df_resume

# üìä Analyse simple (toujours bas√©e sur df_main, non r√©√©chantillonn√©)
df_simple = analyse_simplifiee(df_main)

# üîÅ Nettoyage et v√©rification des doublons
df_simple["Capteur"] = df_simple["Capteur"].astype(str).str.strip()
df_simple["Doublon"] = df_simple["Capteur"].duplicated(keep=False) \
    .map({True: "üîÅ Oui", False: "‚úÖ Non"})
# üßπ Suppression des doublons bas√©s sur le nom nettoy√© (on garde la derni√®re version, la plus "propre")
df_simple = df_simple.drop_duplicates(subset=["Nom_nettoye"], keep="last").reset_index(drop=True)

# üîç Validation selon la r√©f√©rence (si fournie)
if capteurs_reference_cleaned and len(capteurs_reference_cleaned) > 0:
    # 1) Indication si le capteur figure dans la r√©f√©rence nettoy√©e
    df_simple["Dans la r√©f√©rence"] = df_simple["Nom_nettoye"].isin(capteurs_reference_cleaned) \
        .map({True: "‚úÖ Oui", False: "‚ùå Non"})

    # 2) Tri : capteurs valid√©s (‚úÖ) d‚Äôabord
    df_simple = df_simple.sort_values(by="Dans la r√©f√©rence", ascending=False).reset_index(drop=True)

    # 3) Affichages s√©par√©s
    st.subheader("‚úÖ Capteurs trouv√©s dans la r√©f√©rence")
    df_valides = df_simple[df_simple["Dans la r√©f√©rence"] == "‚úÖ Oui"]
    if not df_valides.empty:
        st.dataframe(df_valides[["Capteur", "Dans la r√©f√©rence", "Doublon"]], use_container_width=True)
    else:
        st.markdown("Aucun capteur valide trouv√©.")

    st.subheader("‚ùå Capteurs absents de la r√©f√©rence")
    df_non_valides = df_simple[df_simple["Dans la r√©f√©rence"] == "‚ùå Non"]
    if not df_non_valides.empty:
        st.dataframe(df_non_valides[["Capteur", "Dans la r√©f√©rence", "Doublon"]], use_container_width=True)
    else:
        st.markdown("Tous les capteurs sont pr√©sents dans la r√©f√©rence.")

    # 4) Liste brute des noms non reconnus (utile pour copier/coller)
    if not df_non_valides.empty:
        st.subheader("Liste brute ‚Äì Capteurs du fichier principal absents de la r√©f√©rence")
        st.write(df_non_valides["Capteur"].tolist())

    # 5) Capteurs attendus mais absents dans les donn√©es analys√©es
    capteurs_trouves = set(df_simple["Nom_nettoye"])
    manquants = sorted(capteurs_reference_cleaned - capteurs_trouves)
    if manquants:
        st.subheader("Capteurs attendus non trouv√©s dans les donn√©es analys√©es")
        st.markdown("Voici les capteurs pr√©sents dans le fichier de r√©f√©rence mais absents du fichier principal :")
        df_manquants = pd.DataFrame(manquants, columns=["Capteur (r√©f√©rence manquant dans les donn√©es)"])
        st.dataframe(df_manquants, use_container_width=True)
    else:
        st.markdown("‚úÖ Tous les capteurs attendus sont pr√©sents dans les donn√©es.")      

# --- Analyse de compl√©tude AVEC r√©√©chantillonnage qui conserve toutes les colonnes ---
from pandas.api.types import is_numeric_dtype

def resampler_df(df, frequence_str):
    if "timestamp" not in df.columns:
        st.warning("‚ö†Ô∏è Colonne 'timestamp' non trouv√©e dans le fichier.")
        return df

    st.info(f"‚è±Ô∏è Fr√©quence s√©lectionn√©e : {frequence_str}")

    # Pas de r√©√©chantillonnage demand√©
    if frequence_str == "1min":
        st.info("‚úÖ Pas de r√©√©chantillonnage n√©cessaire (1min).")
        return df.copy()

    try:
        df = df.copy()
        df["timestamp"] = pd.to_datetime(df["timestamp"], errors="coerce")
        df = df.dropna(subset=["timestamp"]).set_index("timestamp")

        # Plan d'agr√©gation colonne par colonne :
        #  - num√©rique  -> mean
        #  - non num.   -> first (pour conserver la colonne et permettre l'analyse de compl√©tude)
        agg_map = {}
        for col in df.columns:
            if col.lower() in ("notes",):   # on laisse vivre si tu as une colonne notes
                agg_map[col] = "first"
            else:
                agg_map[col] = "mean" if is_numeric_dtype(df[col]) else "first"

        df_resampled = df.resample(rule_map[frequence_str]).agg(agg_map).reset_index()
        st.success(f"‚úÖ Donn√©es r√©√©chantillonn√©es avec succ√®s √† {frequence_str}.")
        return df_resampled

    except Exception as e:
        st.error(f"‚ùå Erreur lors du r√©√©chantillonnage : {e}")
        return df.reset_index()

# --- Analyse de compl√©tude (par colonne, num√©rique ou non) ---
def analyser_completude(df):
    if "timestamp" not in df.columns:
        st.error("‚ùå La colonne 'timestamp' est manquante.")
        return pd.DataFrame()

    total = len(df)
    resultat = []

    # On analyse TOUTES les colonnes (sauf timestamp et notes)
    cols = [c for c in df.columns if c.lower() not in ("timestamp", "notes")]

    for col in cols:
        # pr√©sence = entr√©es non nulles (valable aussi pour objets/texte)
        presente = int(df[col].notna().sum())
        manquantes = int(total - presente)
        pct_presente = 100 * presente / total if total > 0 else 0.0
        pct_manquantes = 100 - pct_presente

        # statut visuel
        if pct_presente >= 80:
            statut = "üü¢"
        elif pct_presente > 0:
            statut = "üü†"
        else:
            statut = "üî¥"

        resultat.append({
            "Capteur": str(col).strip(),
            "Pr√©sentes": presente,
            "% Pr√©sentes": round(pct_presente, 2),
            "Manquantes": manquantes,
            "% Manquantes": round(pct_manquantes, 2),
            "Statut": statut
        })

    return pd.DataFrame(resultat)

# üìà Analyse de compl√©tude avec la fr√©quence choisie
st.subheader(f"üìà Analyse de compl√©tude des donn√©es brutes ({frequence})")
df_resample = resampler_df(df_main, frequence)
stats_main = analyser_completude(df_resample)
st.dataframe(stats_main, use_container_width=True)
# üßπ Suppression des doublons sur la colonne Capteur (ex: √ânergie-Froid appara√Æt 2 fois)
stats_main = stats_main.drop_duplicates(subset=["Capteur"], keep="last").reset_index(drop=True)

# üìò L√©gende des statuts (coh√©rente avec les seuils ci-dessus)
st.markdown("""
### üßæ L√©gende des statuts :
- üü¢ : Capteur exploitable (‚â• 80 % de valeurs pr√©sentes)
- üü† : Incomplet (entre 1 % et 79 %)
- üî¥ : Donn√©es absentes (0 %)
""")

# üìå R√©sum√© num√©rique des capteurs selon statut
count_vert = stats_main["Statut"].value_counts().get("üü¢", 0)
count_orange = stats_main["Statut"].value_counts().get("üü†", 0)
count_rouge = stats_main["Statut"].value_counts().get("üî¥", 0)
st.markdown(f"""
**R√©sum√© des capteurs :**
- Capteurs exploitables (üü¢) : `{count_vert}`
- Capteurs incomplets (üü†) : `{count_orange}`
- Capteurs vides (üî¥) : `{count_rouge}`
""")

# üìâ Graphique horizontal final
df_plot = stats_main.sort_values(by="% Pr√©sentes", ascending=True)
fig, ax = plt.subplots(figsize=(10, max(6, len(df_plot) * 0.25)))
sns.barplot(
    data=df_plot,
    y="Capteur",
    x="% Pr√©sentes",
    hue="Statut",
    dodge=False,
    palette={"üü¢": "green", "üü†": "orange", "üî¥": "red"},
    ax=ax
)
plt.title("Compl√©tude des capteurs", fontsize=14)
plt.xlabel("% Donn√©es pr√©sentes")
plt.ylabel("Capteur")
plt.xlim(0, 100)
plt.tight_layout()
st.pyplot(fig)

# ‚úÖ Export Excel final avec couleurs
st.subheader("üì§ Export des r√©sultats (Excel)")

from io import BytesIO

output = BytesIO()

with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
    # √âcriture des feuilles
    df_simple.to_excel(writer, index=False, sheet_name="R√©sum√© capteurs")
    stats_main.to_excel(writer, index=False, sheet_name="Compl√©tude brute")

    if 'df_non_valides' in locals() and not df_non_valides.empty:
        df_non_valides.to_excel(writer, index=False, sheet_name="Capteurs non reconnus")

    if 'df_manquants' in locals() and not df_manquants.empty:
        df_manquants.to_excel(writer, index=False, sheet_name="Capteurs manquants")

    workbook  = writer.book

    #  Format couleur selon le statut
    format_vert = workbook.add_format({'bg_color': '#C6EFCE', 'font_color': '#006100'})
    format_orange = workbook.add_format({'bg_color': '#FFEB9C', 'font_color': '#9C5700'})
    format_rouge = workbook.add_format({'bg_color': '#FFC7CE', 'font_color': '#9C0006'})

    # Appliquer le format √† la feuille "R√©sum√© capteurs"
    feuille = writer.sheets["R√©sum√© capteurs"]
    statut_col = df_simple.columns.get_loc("Statut")  # colonne Statut

    # Appliquer la mise en forme conditionnelle √† la colonne Statut
    feuille.conditional_format(1, statut_col, len(df_simple), statut_col, {
        'type':     'text',
        'criteria': 'containing',
        'value':    'üü¢',
        'format':   format_vert
    })
    feuille.conditional_format(1, statut_col, len(df_simple), statut_col, {
        'type':     'text',
        'criteria': 'containing',
        'value':    'üü†',
        'format':   format_orange
    })
    feuille.conditional_format(1, statut_col, len(df_simple), statut_col, {
        'type':     'text',
        'criteria': 'containing',
        'value':    'üî¥',
        'format':   format_rouge
    })

    #writer.save()

# Bouton de t√©l√©chargement
st.download_button(
    label="üì• T√©l√©charger le rapport Excel ",
    data=output.getvalue(),
    file_name="rapport_capteurs.xlsx",
    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
)













